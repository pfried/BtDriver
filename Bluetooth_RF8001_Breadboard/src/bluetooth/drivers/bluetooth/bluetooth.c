/**
 * @author Friedrich Mäckle
 * @date 2014
 * @copyright IAS, University of Stuttgart, Germany
 *
 * @brief Implementation of the Bluetooth Driver
 * @details This file provides all implementations for the Bluetooth Driver which were necessary for porting the Nordic Semiconductor Arduino Library to Atmel XMega. Both polling and interrupt interface are provided.
 * This file is tightly coupled to the services.h file generated by the nRFGo Studio.
 */ 

#include <asf.h>
#include "bluetooth.h"
#include "../bt_active_led/bt_active_led.h"

#include "characteristics/brightness.h"
#include "characteristics/distance_us_front.h"
#include "characteristics/distance_us_rear.h"
#include "characteristics/distance_ir_front.h"
#include "characteristics/distance_ir_rear.h"
#include "characteristics/battery.h"
#include "characteristics/horn.h"
#include "characteristics/lights.h"
#include "characteristics/speed_mode.h"
#include "characteristics/sensor_servo.h"
#include "characteristics/speed_and_angle.h"
#include "characteristics/generic_actor_1.h"
#include "characteristics/generic_actor_2.h"
#include "characteristics/temperature.h"

#ifdef SERVICES_PIPE_TYPE_MAPPING_CONTENT
/* Services pipes generated by nRFGo Studio from Nordic Semiconductor */
static services_pipe_type_mapping_t services_pipe_type_mapping[NUMBER_OF_PIPES] = SERVICES_PIPE_TYPE_MAPPING_CONTENT;
#else
#define NUMBER_OF_PIPES 0
static services_pipe_type_mapping_t * services_pipe_type_mapping = NULL;
#endif

/* Setup for the nRF8001 bluetooth chip in flash */
static hal_aci_data_t setup_msgs[NB_SETUP_MESSAGES] PROGMEM = SETUP_MESSAGES_CONTENT;

static aci_state_t aci_state;

static hal_aci_evt_t aci_data;
static hal_aci_data_t aci_cmd;

static bool radio_ack_pending  = false;
static bool timing_change_done = false;

// The car model with the current values
static bluetooth_car_t *car;
// To send only new values we save the last state of the car
static bluetooth_car_t oldcar;

uint8_t pipes_open_bitmap_old[PIPES_ARRAY_SIZE];

// Interrupt handler
static bt_callback_t bt_callback;

// Interrupt Vector PORT
// In XMegaE all Pins have a flag in the INTFLAGS register, in XMegaA there is one flag for each interrupt
#if XMEGA_E5
ISR(PORTC_INT_vect) {
	if(bt_callback) {
		bt_callback();
		// Clear the Interrupt, no idea why it doesnt get cleared in ISR
		PORTC.INTFLAGS |= PORT_INT2IF_bm;
	}
}
#endif

#if XMEGA_A
ISR(PORTC_INT0_vect) {
	if(bt_callback) {
		bt_callback();
		// Clear the Interrupt, no idea why it doesnt get cleared in ISR
		PORTC.INTFLAGS |= PORT_INT0IF_bm;
	}
}
#endif

// Implementing missing functions from arduino port
bool digitalRead(port_pin_t pin) {
	return ioport_get_pin_level(pin);
}

void digitalWrite(port_pin_t pin, bool value) {
	ioport_set_pin_level(pin, value);
}

void pinMode(port_pin_t pin,ioport_mode_t mode) {
	ioport_set_pin_mode(pin, mode);
}

void delay(uint16_t ms) {
	delay_ms(ms);
}

void interrupts(void) {
	sei();
}

void noInterrupts(void) {
	cli();
}

void spi_lsb_first(SPI_t *spi) {
	spi->CTRL |= (1 << SPI_DORD_bm);
}

void spi_msb_first(SPI_t * spi) {
	spi->CTRL &= ~(1 << SPI_DORD_bm);
}

uint8_t spi_readwrite_xmega(uint8_t *aci_byte)
{
	uint8_t data;
	spi_write_single(&SPIC, aci_byte);
	while(spi_is_rx_ready(&SPIC) == false) {}
	spi_read_single(&SPIC, &data);
	return data;
}

void spi_init_pins(void) {
	ioport_configure_port_pin(&PORTC, PIN1_bm, IOPORT_PULL_DOWN | IOPORT_DIR_OUTPUT);   //PIN 1 RESET
	ioport_configure_port_pin(&PORTC, PIN2_bm, IOPORT_PULL_UP   | IOPORT_DIR_INPUT);    //PIN 2 RDYN
	ioport_configure_port_pin(&PORTC, PIN3_bm, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT);	//PIN 3 Slave Select / REQ
	ioport_configure_port_pin(&PORTC, PIN4_bm, IOPORT_PULL_UP | IOPORT_DIR_INPUT);		//PIN 4 Pull_Up (pull low -> slave mode)
	ioport_configure_port_pin(&PORTC, PIN5_bm, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT);	//PIN 5 MOSI out
	ioport_configure_port_pin(&PORTC, PIN6_bm, IOPORT_DIR_INPUT);						//PIN 6 MISO
	ioport_configure_port_pin(&PORTC, PIN7_bm, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT);	//PIN 7 SCL out
}

void attachInterrupt(port_pin_t pin, void (*f)(void), bool level) {
	// Attach the interrupt to our handler
	bt_callback = f;
	// Activate the interrupt on the pin
	#if XMEGA_E
	PORTC.INTMASK |= PIN2_bm;
	#endif
	
	#if XMEGA_A
	PORTC.INT0MASK |= PIN2_bm;
	#endif
}

void detachInterrupt(port_pin_t pin) {
	// Deactivate the interrupt on the pin
	#if XMEGA_E
	PORTC.INTMASK |= ~PIN2_bm;
	#endif
	
	#if XMEGA_A
	PORTC.INT0MASK |= ~PIN2_bm;
	#endif
}

static bool temperature_counter_flag = false;

void temperature_ovf_interrupt_callback(void) {
	temperature_counter_flag = true;
	tc45_clear_overflow(&TCC4);
}


void bluetooth_init(bluetooth_config_t *bluetooth_config, bluetooth_car_t *bluetooth_car) {
	
	car = bluetooth_car;
	oldcar = *bluetooth_car;
	
	spi_init_pins();

	/**
	Point ACI data structures to the the setup data that the nRFgo studio generated for the nRF8001
	*/
	if (NULL != services_pipe_type_mapping)
	{
	aci_state.aci_setup_info.services_pipe_type_mapping = &services_pipe_type_mapping[0];
	}
	else
	{
	aci_state.aci_setup_info.services_pipe_type_mapping = NULL;
	}
  
	aci_state.aci_setup_info.number_of_pipes    = NUMBER_OF_PIPES;
	aci_state.aci_setup_info.setup_msgs         = setup_msgs;
	aci_state.aci_setup_info.num_setup_msgs     = NB_SETUP_MESSAGES;
  
	/*
	Tell the ACI library, the MCU to nRF8001 pin connections.
	The Active pin is optional and can be marked UNUSED
	*/
	aci_state.aci_pins.board_name = BOARD_DEFAULT; // Set to default
	aci_state.aci_pins.reqn_pin   = bluetooth_config->reqn_pin;
	aci_state.aci_pins.rdyn_pin   = bluetooth_config->rdyn_pin;
	aci_state.aci_pins.mosi_pin   = MOSI;
	aci_state.aci_pins.miso_pin   = MISO;
	aci_state.aci_pins.sck_pin    = SCK;
  
	aci_state.aci_pins.spi = &SPIC;

	aci_state.aci_pins.reset_pin              = BT_RST;
	aci_state.aci_pins.active_pin             = UNUSED;
	aci_state.aci_pins.optional_chip_sel_pin  = UNUSED;

	aci_state.aci_pins.interface_is_interrupt = true;
	aci_state.aci_pins.interrupt_number       = bluetooth_config->rdyn_pin;
	
	// Interrupt Config
	// Set the interrupt level on the port
	PORTC.PIN2CTRL |= PORT_ISC_FALLING_gc;
	
	// Set priority to low for PORTC
	#if XMEGA_E
	PORTC.INTCTRL |= PORT_INTLVL_LO_gc;
	#endif
	
	#if XMEGA_A
	PORTC.INTCTRL |= PORT_INT0LVL_LO_gc;
	#endif
	
	// Enable Low Level Interrupts on PMIC
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
	
	/** We reset the nRF8001 here by toggling the RESET line connected to the nRF8001
	*  and initialize the data structures required to setup the nRF8001
	*/
	//The second parameter is for turning debug printing on for the ACI Commands and Events so they be printed on the Serial
	lib_aci_init(&aci_state,false);
	
	// Enable Timer
	#if XMEGA_E
	tc45_enable(&TCC4);
	tc45_set_wgm(&TCC4, TC45_WG_NORMAL);
	tc45_set_overflow_interrupt_callback(&TCC4, temperature_ovf_interrupt_callback);
	tc45_set_overflow_interrupt_level(&TCC4, TC45_INT_LVL_LO);
	tc45_write_clock_source(&TCC4, TC45_CLKSEL_DIV1024_gc);
	#endif
}

void bluetooth_process(void) {
	
	// The Setup needs to be transfered to the NRF8001 Chip on startup, flag indicates if we need to setup the device
	static bool setup_required = false;
	
	static uint16_t oldVal = 0x0000;
	
	// Basically getting events from the event queue
	if(lib_aci_event_get(&aci_state, &aci_data)) {
		
		aci_evt_t * aci_evt;
		aci_evt = &aci_data.evt;
		
		switch(aci_evt->evt_opcode)
		{
			case ACI_EVT_DEVICE_STARTED:
			{
				aci_state.data_credit_total = aci_evt->params.device_started.credit_available;
				switch(aci_evt->params.device_started.device_mode)
				{
					case ACI_DEVICE_SETUP:
						/**
						When the device is in the setup mode
						*/
						setup_required = true;
						break;

					case ACI_DEVICE_STANDBY:
						//Looking for a Phone by sending radio advertisements
						//When a phone connects to us we will get an ACI_EVT_CONNECTED event from the nRF8001
						if (aci_evt->params.device_started.hw_error)
						{
							delay(20); //Handle the HW error event correctly.
						}
						else
						{
							lib_aci_connect(0/* in seconds : 0 means forever */, 0x0050 /* advertising interval 50ms*/);
						}

						break;
				}
				break; //ACI Device Started Event
			}
			
			case ACI_EVT_CONNECTED:
			{
				// Set the available credits
				aci_state.data_credit_available = aci_state.data_credit_total;
				timing_change_done = false;

				//Get the device version of the nRF8001 and store it in the Hardware Revision String
				lib_aci_device_version();
				BT_LED_On();
				break;
			}
			
			case ACI_EVT_DISCONNECTED:
			{
				BT_LED_Off();
				timing_change_done = false;
				lib_aci_connect(0/* in seconds  : 0 means forever */, 0x0050 /* advertising interval 50ms*/);
				break;
			}
			
			// We receive data from the Central
			case ACI_EVT_DATA_RECEIVED:
			{
				switch(aci_evt->params.data_received.rx_data.pipe_number) {
					// Speed and Angle
					case PIPE_DRIVE_SPEEDANDANGLE_RX:
					{
						car->speed = ((uint16_t) aci_evt->params.data_received.rx_data.aci_data[0] << 8) | aci_evt->params.data_received.rx_data.aci_data[1];
						car->direction = ((uint16_t) aci_evt->params.data_received.rx_data.aci_data[2] << 8) | aci_evt->params.data_received.rx_data.aci_data[3];
						break;
					}
					
					// Speed Mode
					case PIPE_DRIVE_SPEEDMODE_RX_ACK_AUTO:
					{
						car->speedMode = aci_evt->params.data_received.rx_data.aci_data[0];
						break;
					}
					
					// Sensor Sevo
					case PIPE_DISTANCE_SENSORSERVO_RX:
					{
						car->sensorServo = ((uint16_t) aci_evt->params.data_received.rx_data.aci_data[0] << 8) | aci_evt->params.data_received.rx_data.aci_data[1];
						break;
					}
					// The Horn, möp möp
					case PIPE_HORN_HORN_RX:
					{
						car->horn = aci_evt->params.data_received.rx_data.aci_data[0];
						break;
					}
					// The lights and blinkers
					case PIPE_LIGHTS_LIGHTS_RX_ACK_AUTO:
					{
						car->lights = aci_evt->params.data_received.rx_data.aci_data[0];
						break;
					}
					// The Generic Actors
					case PIPE_GENERIC_GENERICACTOR1_RX_ACK_AUTO:
					{
						car->generic_actor_1 = ((uint16_t) aci_evt->params.data_received.rx_data.aci_data[0] << 8) | aci_evt->params.data_received.rx_data.aci_data[1];
						break;
					}
					case PIPE_GENERIC_GENERICACTOR2_RX_ACK_AUTO:
					{
						car->generic_actor_2 = ((uint16_t) aci_evt->params.data_received.rx_data.aci_data[0] << 8) | aci_evt->params.data_received.rx_data.aci_data[1];
						break;
					}
					
				}
				break;
			}
			
			// Central received data
			case ACI_EVT_DATA_ACK:
			{
				break;
			}
			
			case ACI_EVT_BOND_STATUS:
			{
				break;
			}
			
			// If the bluetooth central requests data it opens a pipe on the nrf, so we can send data in reply
			case ACI_EVT_PIPE_STATUS:
			{
				/** check if the peer has subscribed to
				*/
				if (false == timing_change_done)
				{
					/*
					Request a change to the link timing as set in the GAP -> Preferred Peripheral Connection Parameters
					Change the setting in nRFgo studio -> nRF8001 configuration -> GAP Settings and recompile the xml file.
					*/
					lib_aci_change_timing_GAP_PPCP();
				}
				else {
					// If someone subscribes we want to send a first value to the subscriptor
					brightness_on_pipe_status(&aci_state, &car->brightness);
					distance_us_front_on_pipe_status(&aci_state, &car->distance_us_front);
					distance_us_rear_on_pipe_status(&aci_state, &car->distance_us_rear);
					distance_ir_front_on_pipe_status(&aci_state, &car->distance_ir_front);
					distance_ir_rear_on_pipe_status(&aci_state, &car->distance_ir_rear);
					battery_on_pipe_status(&aci_state, &car->battery);
					horn_on_pipe_status(&aci_state, &car->horn);
					lights_on_pipe_status(&aci_state, &car->horn);
					speed_mode_on_pipe_status(&aci_state, &car->speedMode);
					sensor_servo_on_pipe_status(&aci_state, &car->sensorServo);
					speed_and_angle_on_pipe_status(&aci_state, &car->speed, &car->direction);
					generic_actor_1_on_pipe_status(&aci_state, &car->generic_actor_1);
					generic_actor_2_on_pipe_status(&aci_state, &car->generic_actor_2);
					temperature_on_pipe_status(&aci_state, &car->temperature);
				}
				
				break;
			}
			
			// Transmission Failure
			case ACI_EVT_PIPE_ERROR:
			{
				/**
				Send data failed. ACI_EVT_DATA_CREDIT will not come.
				This can happen if the pipe becomes unavailable by the peer unsubscribing to a characteristic
				This can also happen when the link is disconnected after the data packet has been sent.
				*/
				radio_ack_pending = false;
				
				//Increment the credit available as the data packet was not sent.
				//The pipe error also represents the Attribute protocol Error Response sent from the peer and that should not be counted
				//for the credit.
				if (ACI_STATUS_ERROR_PEER_ATT_ERROR != aci_evt->params.pipe_error.error_code)
				{
					aci_state.data_credit_available++;
				}
				
				break;
			}
			
			
			// Credits limit the command buffer available on the nRF8001, if a command is executed we are notified by the return of a credit
			case ACI_EVT_DATA_CREDIT:
			{
				aci_state.data_credit_available = aci_state.data_credit_available + aci_evt->params.data_credit.credit;
				/**
				Bluetooth Radio ack received from the peer radio for the data packet sent.
				This also signals that the buffer used by the nRF8001 for the data packet is available again.
				*/
				radio_ack_pending = false;
				break;
			}

			// Returned by set local data
			case ACI_EVT_CMD_RSP:
			{
				//If an ACI command response event comes with an error -> stop
				if (ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status)
				{
					//ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
					//TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
					//all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command
					
				}
				else {
					switch (aci_evt->params.cmd_rsp.cmd_opcode)
					{
						case ACI_CMD_GET_TEMPERATURE:
						{
							car->temperature = aci_evt->params.cmd_rsp.params.get_temperature.temperature_value;
							break;
						}
						
					}
					
				}
				
				break;
			}
			
			case ACI_EVT_ECHO:
			{
				break;
			}
			
			// Timing has change, we do not need to do anything here
			case ACI_EVT_TIMING:
			{
				timing_change_done = true;
				break;
			}
			
			case ACI_EVT_HW_ERROR:
			{
				break;
			}
			
		}
	}
	
	if(setup_required)
	{
		if (SETUP_SUCCESS == do_aci_setup(&aci_state))
		{
			// We set the device name which appears in the Scan data (advertising is configured in nRF Go Studio)
			lib_aci_set_local_data(PIPE_GAP_DEVICE_NAME_SET, car->name, PIPE_GAP_DEVICE_NAME_SET_MAX_SIZE);
			
			// We init our characteristics with a reference to the oldCar's struct member
			brightness_init(&oldcar.brightness);
			distance_us_front_init(&oldcar.distance_us_front);
			distance_us_rear_init(&oldcar.distance_us_rear);
			distance_ir_front_init(&oldcar.distance_ir_front);
			distance_ir_rear_init(&oldcar.distance_ir_rear);
			battery_init(&oldcar.battery);
			horn_init(&oldcar.horn);
			lights_init(&oldcar.lights);
			speed_mode_init(&oldcar.speedMode);
			sensor_servo_init(&oldcar.sensorServo);
			speed_and_angle_init(&oldcar.speed, &oldcar.direction);
			generic_actor_1_init(&oldcar.generic_actor_1);
			generic_actor_2_init(&oldcar.generic_actor_2);
			temperature_init(&oldcar.temperature);
			
			
			
			setup_required = false;
		}
	}
	
	// Do the transmission of the cars values
	bluetooth_values_process();
	
}

void bluetooth_values_process(void) {
	
	// We are in connected mode if timing is done
	if(timing_change_done == true) {
		
		// Send the new values to the characteristics, they decide what to do
		brightness_update(&aci_state, &car->brightness);
		distance_us_front_update(&aci_state, &car->distance_us_front);
		distance_us_rear_update(&aci_state, &car->distance_us_rear);
		distance_ir_front_update(&aci_state, &car->distance_ir_front);
		distance_ir_rear_update(&aci_state, &car->distance_ir_rear);
		battery_update(&aci_state, &car->battery);
		horn_update(&aci_state, &car->horn);
		lights_update(&aci_state, &car->lights);
		speed_mode_update(&aci_state, &car->speedMode);
		sensor_servo_update(&aci_state, &car->sensorServo);
		speed_and_angle_update(&aci_state, &car->speed, &car->direction);
		generic_actor_1_update(&aci_state, &car->generic_actor_1);
		generic_actor_2_update(&aci_state, &car->generic_actor_2);
		temperature_update(&aci_state, &car->temperature);
		
		// Request a temperature value timer based, the timer sets the flag		
		if(temperature_counter_flag == true) {
			lib_aci_get_temperature();
			temperature_counter_flag = false;
		}
	}
}

void bluetooth_get_config_defaults(bluetooth_config_t *bluetooth_config) {
	bluetooth_config->spi = &SPIC;
	bluetooth_config->reqn_pin = REQN;
	bluetooth_config->rdyn_pin = RDYN;
}